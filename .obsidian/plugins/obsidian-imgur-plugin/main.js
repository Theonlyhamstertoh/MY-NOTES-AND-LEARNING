/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/ImgurPlugin.ts
var ImgurPlugin_exports = {};
__export(ImgurPlugin_exports, {
  default: () => ImgurPlugin
});
module.exports = __toCommonJS(ImgurPlugin_exports);
var import_obsidian6 = require("obsidian");

// src/ui/ImgurPluginSettingsTab.ts
var import_obsidian3 = require("obsidian");

// src/imgur/constants.ts
var IMGUR_PLUGIN_CLIENT_ID = "5d3647b14ed585f";
var IMGUR_API_BASE = "https://api.imgur.com/3/";
var IMGUR_ACCESS_TOKEN_LOCALSTORAGE_KEY = "imgur-access_token";

// src/UploadStrategy.ts
var _UploadStrategy = class {
  constructor(id, description) {
    this.id = id;
    this.description = description;
    _UploadStrategy.valuesArr.push(this);
  }
  static get values() {
    return this.valuesArr;
  }
};
var UploadStrategy = _UploadStrategy;
UploadStrategy.valuesArr = [];
UploadStrategy.ANONYMOUS_IMGUR = new _UploadStrategy("ANONYMOUS_IMGUR", "Anonymous Imgur upload");
UploadStrategy.AUTHENTICATED_IMGUR = new _UploadStrategy("AUTHENTICATED_IMGUR", "Authenticated Imgur upload");

// src/ui/ImgurAuthenticationStatus.ts
var import_obsidian2 = require("obsidian");

// src/uploader/ApiError.ts
var ApiError = class extends Error {
};

// src/uploader/imgur/ImgurAuthenticatedUploader.ts
var ImgurAuthenticatedUploader = class {
  constructor(client) {
    this.client = client;
  }
  upload(image) {
    return __async(this, null, function* () {
      return (yield this.client.upload(image)).data.link;
    });
  }
};

// src/ui/ImgurAuthModal.ts
var import_obsidian = require("obsidian");
var ONE_SECOND_MILLIS = 1e3;
var OPEN_BROWSER_IN_SECONDS = 4;
var ImgurAuthModal = class extends import_obsidian.Modal {
  constructor(clientId, app, afterClose) {
    super(app);
    this.afterClose = afterClose;
    this.secondsLeft = OPEN_BROWSER_IN_SECONDS;
    this.opened = false;
    this.intervalId = null;
    this.authLink = `https://api.imgur.com/oauth2/authorize?client_id=${clientId}&response_type=token`;
  }
  get isOpen() {
    return this.opened;
  }
  onOpen() {
    this.opened = true;
    this.timerDiv = this.modalEl.createDiv();
    this.updateText();
    this.intervalId = setInterval(() => {
      this.secondsLeft -= 1;
      this.updateText();
      if (this.secondsLeft === 0) {
        window.open(this.authLink);
        clearInterval(this.intervalId);
      }
    }, ONE_SECOND_MILLIS);
    this.addNoWaitDiv(this.intervalId);
    new import_obsidian.ButtonComponent(this.modalEl.createDiv()).setButtonText("Cancel").setCta().onClick(() => this.close());
  }
  onClose() {
    return __async(this, null, function* () {
      clearInterval(this.intervalId);
      this.opened = false;
      if (this.afterClose)
        yield this.afterClose();
    });
  }
  addNoWaitDiv(interval) {
    const linkEl = createEl("a", { href: this.authLink, text: "here" });
    const noWaitDiv = this.modalEl.createDiv();
    noWaitDiv.appendText("If you do not want to wait, click ");
    noWaitDiv.append(linkEl);
    linkEl.onclick = () => {
      clearInterval(interval);
      this.secondsLeft = 0;
      this.updateText();
    };
    return noWaitDiv;
  }
  updateText() {
    this.timerDiv.setText(`Please complete authentication at imgur.com; Opening browser in ${this.secondsLeft} seconds...`);
  }
};

// src/ui/ImgurAuthenticationStatus.ts
var ImgurAuthenticationStatus = class {
  constructor(parent, settingsTab) {
    this.parent = parent;
    this.settingsTab = settingsTab;
  }
  display() {
    return __async(this, null, function* () {
      const settingItem = this.parent.createDiv();
      settingItem.addClass("setting-item");
      const settingItemInfo = settingItem.createDiv();
      settingItemInfo.addClass("setting-item-info");
      const settingItemControl = settingItem.createDiv();
      settingItemControl.addClass("setting-item-control");
      this.authStatusDiv = settingItemInfo.createDiv();
      this.buttonsDiv = settingItemControl;
      yield this.updateAll();
    });
  }
  updateAll() {
    return __async(this, null, function* () {
      this.authStatusDiv.empty();
      this.buttonsDiv.empty();
      yield this.updateStatus();
      this.drawButtons();
    });
  }
  updateStatus() {
    return __async(this, null, function* () {
      const uploader = this.getAuthenticatedUploader();
      if (!uploader) {
        this.setNotAuthenticated();
        return;
      }
      this.authStatusDiv.setText("Checking Imgur authentication...");
      try {
        const currentUserName = (yield uploader.client.accountInfo()).data.url;
        this.authStatusDiv.setText(`Authenticated as: ${currentUserName} \u2705`);
        this.authenticated = true;
      } catch (e) {
        if (e instanceof TypeError && e.message === "Failed to fetch") {
          this.authStatusDiv.setText("Internet connection problem");
        } else if (e instanceof ApiError) {
          this.authStatusDiv.setText(`Imgur session error: ${e.message}`);
        } else {
          console.warn("Not authenticated, exception: ", e);
          this.setNotAuthenticated();
        }
      }
    });
  }
  getAuthenticatedUploader() {
    if (this.settingsTab.plugin.imgUploader && this.settingsTab.plugin.imgUploader instanceof ImgurAuthenticatedUploader) {
      return this.settingsTab.plugin.imgUploader;
    }
    return null;
  }
  setNotAuthenticated() {
    this.authStatusDiv.setText("Not authenticated");
    this.authenticated = false;
  }
  drawButtons() {
    if (this.authenticated) {
      this.addLogoutButton(this.buttonsDiv);
    } else {
      this.addAuthButton(this.buttonsDiv);
    }
  }
  addLogoutButton(el) {
    new import_obsidian2.ButtonComponent(el).setButtonText("Logout").setWarning().onClick(() => __async(this, null, function* () {
      localStorage.removeItem(IMGUR_ACCESS_TOKEN_LOCALSTORAGE_KEY);
      this.settingsTab.plugin.setupImagesUploader();
      yield this.updateAll();
    }));
  }
  addAuthButton(parentEl) {
    new import_obsidian2.ButtonComponent(parentEl).setButtonText("Authenticate").setCta().onClick(() => {
      const modal = new ImgurAuthModal(IMGUR_PLUGIN_CLIENT_ID, this.settingsTab.app, () => __async(this, null, function* () {
        yield this.updateAll();
      }));
      modal.open();
      this.settingsTab.authModal = modal;
    });
  }
};

// src/ui/ImgurPluginSettingsTab.ts
var REGISTER_CLIENT_URL = "https://api.imgur.com/oauth2/addclient";
var ImgurPluginSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin.registerObsidianProtocolHandler("imgur-oauth", (params) => {
      if (!this.authModal || !this.authModal.isOpen)
        return;
      if (params.error) {
        new import_obsidian3.Notice(`Authentication failed with error: ${params.error}`);
        return;
      }
      const mappedData = params.hash.split("&").map((p) => {
        const sp = p.split("=");
        return [sp[0], sp[1]];
      });
      const map = new Map(mappedData);
      localStorage.setItem(IMGUR_ACCESS_TOKEN_LOCALSTORAGE_KEY, map.get("access_token"));
      this.plugin.setupImagesUploader();
      this.authModal.close();
      this.authModal = null;
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Imgur Plugin settings" });
    const uploadApproachDiv = containerEl.createDiv();
    this.strategyDiv = containerEl.createDiv();
    new import_obsidian3.Setting(uploadApproachDiv).setName("Images upload approach").addDropdown((dropdown) => {
      UploadStrategy.values.forEach((s) => {
        dropdown.addOption(s.id, s.description);
      });
      dropdown.setValue(this.plugin.settings.uploadStrategy);
      dropdown.onChange((v) => __async(this, null, function* () {
        this.plugin.settings.uploadStrategy = v;
        this.plugin.setupImagesUploader();
        yield this.drawSettings(this.strategyDiv);
      }));
    });
    this.drawSettings(this.strategyDiv).then(() => {
    }).finally(() => {
    });
    new import_obsidian3.Setting(containerEl).setName("Confirm before upload").addToggle((t) => {
      t.setValue(this.plugin.settings.showRemoteUploadConfirmation);
      t.onChange((newValue) => {
        this.plugin.settings.showRemoteUploadConfirmation = newValue;
      });
    });
  }
  hide() {
    return __async(this, null, function* () {
      yield this.plugin.saveSettings();
      this.plugin.setupImagesUploader();
    });
  }
  drawSettings(parentEl) {
    return __async(this, null, function* () {
      parentEl.empty();
      switch (this.plugin.settings.uploadStrategy) {
        case UploadStrategy.ANONYMOUS_IMGUR.id:
          this.drawAnonymousClientIdSetting(parentEl);
          break;
        case UploadStrategy.AUTHENTICATED_IMGUR.id:
          yield new ImgurAuthenticationStatus(parentEl, this).display();
          break;
        default:
          throw new Error("There must be a bug, this code is not expected to be reached");
      }
    });
  }
  drawAnonymousClientIdSetting(containerEl) {
    new import_obsidian3.Setting(containerEl).setName("Client ID").setTooltip(`Client ID is required for anonymous images upload. If you do not provide your own Client ID, the one shipped with the plugin and shared with many other users will be used. If you face issues with images upload, it's better generate your own Client ID"`).setDesc(ImgurPluginSettingsTab.clientIdSettingDescription()).addText((text) => text.setPlaceholder("Enter your client_id").setValue(this.plugin.settings.clientId).onChange((value) => {
      this.plugin.settings.clientId = value;
    }));
  }
  static clientIdSettingDescription() {
    const fragment = document.createDocumentFragment();
    const a = document.createElement("a");
    a.textContent = REGISTER_CLIENT_URL;
    a.setAttribute("href", REGISTER_CLIENT_URL);
    fragment.append("Generate your own Client ID at ");
    fragment.append(a);
    return fragment;
  }
};

// src/imgur/ImgurClient.ts
function handleImgurErrorResponse(resp) {
  return __async(this, null, function* () {
    if (resp.headers.get("Content-Type") === "application/json") {
      throw new ApiError((yield resp.json()).data.error);
    }
    throw new Error(yield resp.text());
  });
}
var ImgurClient = class {
  constructor(accessToken) {
    this.accessToken = accessToken;
  }
  accountInfo() {
    return __async(this, null, function* () {
      const r = yield fetch(`${IMGUR_API_BASE}account/me`, {
        headers: new Headers({ Authorization: `Bearer ${this.accessToken}` })
      });
      if (!r.ok) {
        yield handleImgurErrorResponse(r);
      }
      return yield r.json();
    });
  }
  upload(image) {
    return __async(this, null, function* () {
      const requestData = new FormData();
      requestData.append("image", image);
      const resp = yield fetch(`${IMGUR_API_BASE}image`, {
        method: "POST",
        headers: new Headers({ Authorization: `Bearer ${this.accessToken}` }),
        body: requestData
      });
      if (!resp.ok) {
        yield handleImgurErrorResponse(resp);
      }
      return yield resp.json();
    });
  }
};

// src/uploader/imgur/ImgurAnonymousUploader.ts
var ImgurAnonymousUploader = class {
  constructor(clientId) {
    this.clientId = clientId;
  }
  upload(image) {
    return __async(this, null, function* () {
      const requestData = new FormData();
      requestData.append("image", image);
      const resp = yield fetch(`${IMGUR_API_BASE}image`, {
        method: "POST",
        headers: new Headers({ Authorization: `Client-ID ${this.clientId}` }),
        body: requestData
      });
      if (!resp.ok) {
        yield handleImgurErrorResponse(resp);
      }
      return (yield resp.json()).data.link;
    });
  }
};

// src/uploader/imgUploaderFactory.ts
function defaultAnonymousUploader() {
  return new ImgurAnonymousUploader(IMGUR_PLUGIN_CLIENT_ID);
}
function buildUploaderFrom(settings) {
  if (UploadStrategy.AUTHENTICATED_IMGUR.id === settings.uploadStrategy) {
    const accessToken = localStorage.getItem(IMGUR_ACCESS_TOKEN_LOCALSTORAGE_KEY);
    if (!accessToken) {
      return void 0;
    }
    return new ImgurAuthenticatedUploader(new ImgurClient(accessToken));
  }
  if (settings.uploadStrategy === UploadStrategy.ANONYMOUS_IMGUR.id) {
    if (settings.clientId) {
      return new ImgurAnonymousUploader(settings.clientId);
    }
    return defaultAnonymousUploader();
  }
  throw Error("This line of code should never be reached");
}

// src/ui/RemoteUploadConfirmationDialog.ts
var import_obsidian4 = require("obsidian");
var RemoteUploadConfirmationDialog = class extends import_obsidian4.Modal {
  constructor() {
    super(...arguments);
    this.userResponded = false;
    this.resp = new Promise((resolve) => {
      this.deferredResolve = resolve;
    });
  }
  response() {
    return __async(this, null, function* () {
      return this.resp;
    });
  }
  onOpen() {
    this.titleEl.setText("Imgur plugin");
    this.contentEl.setText("Would you like to upload to Imgur or paste your content locally?");
    const buttonsDiv = this.modalEl.createDiv("modal-button-container");
    new import_obsidian4.ButtonComponent(buttonsDiv).setButtonText("Always upload").setCta().onClick(() => {
      this.deferredResolve({ shouldUpload: true, alwaysUpload: true });
      this.afterUserInput();
    });
    new import_obsidian4.ButtonComponent(buttonsDiv).setButtonText("Upload").setCta().onClick(() => {
      this.deferredResolve({ shouldUpload: true });
      this.afterUserInput();
    });
    new import_obsidian4.ButtonComponent(buttonsDiv).setButtonText("Paste locally").onClick(() => {
      this.deferredResolve({ shouldUpload: false });
      this.afterUserInput();
    });
  }
  afterUserInput() {
    this.userResponded = true;
    this.close();
  }
  onClose() {
    if (!this.userResponded)
      this.deferredResolve({ shouldUpload: void 0 });
  }
};

// src/aux-event-classes/PasteEventCopy.ts
var PasteEventCopy = class extends ClipboardEvent {
  constructor(originalEvent) {
    const { files } = originalEvent.clipboardData;
    const dt = new DataTransfer();
    for (let i = 0; i < files.length; i += 1) {
      dt.items.add(files.item(i));
    }
    super("paste", { clipboardData: dt });
  }
};

// src/aux-event-classes/DragEventCopy.ts
var DragEventCopy = class extends DragEvent {
  static create(fromEvent, files) {
    const dataTransfer = new DataTransfer();
    for (let i = 0; i < files.length; i += 1) {
      dataTransfer.items.add(files[i]);
    }
    return new DragEventCopy(fromEvent.type, {
      dataTransfer,
      clientX: fromEvent.clientX,
      clientY: fromEvent.clientY
    });
  }
};

// src/imgur/resizing/plugin-callback.ts
var import_obsidian5 = require("obsidian");

// src/imgur/resizing/MarkdownImagePieces.ts
function isWrapped(img) {
  return "urlPrefix" in img && "urlSuffix" in img;
}
var IMGUR_IMAGE_ID_LENGTH = 7;
var RESIZED_IMGUR_IMAGE_ID_LENGTH = IMGUR_IMAGE_ID_LENGTH + 1;
function isImageIdOfExpectedSize(imageId) {
  return [IMGUR_IMAGE_ID_LENGTH, RESIZED_IMGUR_IMAGE_ID_LENGTH].includes(imageId.length);
}
function mdImagePiecesFrom(arr) {
  const imageId = arr[4];
  if (!isImageIdOfExpectedSize(imageId))
    throw Error("Imgur image id is of unexpcted size");
  return __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, arr[1] && { urlPrefix: arr[1] }), {
    imgPrefix: arr[2],
    imgurhost: arr[3],
    imageId: imageId.slice(0, IMGUR_IMAGE_ID_LENGTH),
    imageExt: arr[5]
  }), arr[6] && { urlSuffix: arr[6] }), {
    startIndex: arr.index,
    endIndex: arr.index + arr[0].length
  });
}

// src/imgur/resizing/md-image-parsing.ts
var imgurImageRegexp = /(\[)?(!\[[^[\]]*\]\()(https?:\/\/(?:i\.)?imgur\.com\/)(\w+)\.(png|jpe?g|gif)\)(]\(https?:\/\/(?:i\.)?imgur\.com\/\w+\.(?:png|jpe?g|gif)\))?/gm;
var parseImgurImages = (line) => line.matchAll(imgurImageRegexp);
var isMatchUnderCursor = (match, cursorPosition) => cursorPosition >= match.index && cursorPosition < match.index + match[0].length;
var MatchWrapper = class {
  constructor(match) {
    this.match = match;
  }
  get exists() {
    return !!this.match;
  }
  get mdImagePieces() {
    return mdImagePiecesFrom(this.match);
  }
};
var findImgurMarkdownImage = (str, cursorPosOnStr) => {
  const allMatchedOnStr = parseImgurImages(str);
  const matchUnderCursor = Array.from(allMatchedOnStr).find((match) => isMatchUnderCursor(match, cursorPosOnStr));
  return new MatchWrapper(matchUnderCursor);
};
var md_image_parsing_default = findImgurMarkdownImage;

// src/imgur/resizing/ImgurSize.ts
var _ImgurSize = class {
  constructor(suffix, description, sizeHint) {
    this.suffix = suffix;
    this.description = description;
    this.sizeHint = sizeHint;
    _ImgurSize.VALUES.push(this);
  }
  static values() {
    return _ImgurSize.VALUES;
  }
  toString() {
    return this.description;
  }
};
var ImgurSize = _ImgurSize;
ImgurSize.VALUES = [];
ImgurSize.SMALL_SQUARE = new _ImgurSize("s", "Small square", "90x90");
ImgurSize.BIG_SQUARE = new _ImgurSize("b", "Big square", "160x160");
ImgurSize.SMALL_THUMBNAIL = new _ImgurSize("t", "Small Thumbnail", "160x160");
ImgurSize.MEDIUM_THUMBNAIL = new _ImgurSize("m", "Medium Thumbnail", "320x320");
ImgurSize.LARGE_THUMBNAIL = new _ImgurSize("l", "Large Thumbnail", "640x640");
ImgurSize.HUGE_THUMBNAIL = new _ImgurSize("h", "Huge Thumbnail", "1024x1024");
ImgurSize.ORIGINAL = new _ImgurSize("", "Original size");

// src/imgur/resizing/resizing.ts
var resizeTo = (size) => (pieces) => {
  let replacement;
  const resizedUrl = `${pieces.imgPrefix}${pieces.imgurhost}${pieces.imageId}${size.suffix}.${pieces.imageExt})`;
  if (size === ImgurSize.ORIGINAL) {
    replacement = resizedUrl;
  } else if (isWrapped(pieces)) {
    replacement = `${pieces.urlPrefix}${resizedUrl}${pieces.urlSuffix}`;
  } else {
    replacement = `[${resizedUrl}](${pieces.imgurhost}${pieces.imageId}.${pieces.imageExt})`;
  }
  return {
    content: replacement,
    from: pieces.startIndex,
    to: pieces.endIndex
  };
};
var resizing_default = resizeTo;

// src/imgur/resizing/plugin-callback.ts
var editorCheckCallbackFor = (size) => (checking, editor) => {
  const lineNumber = editor.getCursor().line;
  const match = md_image_parsing_default(editor.getLine(lineNumber), editor.getCursor().ch);
  if (!match.exists)
    return false;
  if (checking && match.exists)
    return true;
  let replacement;
  try {
    replacement = resizing_default(size)(match.mdImagePieces);
  } catch (e) {
    if (e instanceof Error)
      new import_obsidian5.Notice(e.message);
    else
      console.error(e);
    return false;
  }
  editor.replaceRange(replacement.content, { line: lineNumber, ch: replacement.from }, { line: lineNumber, ch: replacement.to });
  return true;
};
var plugin_callback_default = editorCheckCallbackFor;

// src/ImgurPlugin.ts
var DEFAULT_SETTINGS = {
  uploadStrategy: UploadStrategy.ANONYMOUS_IMGUR.id,
  clientId: null,
  showRemoteUploadConfirmation: true
};
function allFilesAreImages(files) {
  if (files.length === 0)
    return false;
  for (let i = 0; i < files.length; i += 1) {
    if (!files[i].type.startsWith("image"))
      return false;
  }
  return true;
}
var ImgurPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.customPasteEventCallback = (e, _, markdownView) => __async(this, null, function* () {
      if (e instanceof PasteEventCopy)
        return;
      if (!this.imgUploader) {
        ImgurPlugin.showUnconfiguredPluginNotice();
        return;
      }
      const { files } = e.clipboardData;
      if (!allFilesAreImages(files))
        return;
      e.preventDefault();
      if (this.settings.showRemoteUploadConfirmation) {
        const modal = new RemoteUploadConfirmationDialog(this.app);
        modal.open();
        const userResp = yield modal.response();
        switch (userResp.shouldUpload) {
          case void 0:
            return;
          case true:
            if (userResp.alwaysUpload) {
              this.settings.showRemoteUploadConfirmation = false;
              this.saveSettings().then(() => {
              }).catch(() => {
              });
            }
            break;
          case false:
            markdownView.currentMode.clipboardManager.handlePaste(new PasteEventCopy(e));
            return;
          default:
            return;
        }
      }
      for (let i = 0; i < files.length; i += 1) {
        this.uploadFileAndEmbedImgurImage(files[i]).catch(() => {
          markdownView.currentMode.clipboardManager.handlePaste(new PasteEventCopy(e));
        });
      }
    });
    this.customDropEventListener = (e, _, markdownView) => __async(this, null, function* () {
      if (e instanceof DragEventCopy)
        return;
      if (!this.imgUploader) {
        ImgurPlugin.showUnconfiguredPluginNotice();
        return;
      }
      if (e.dataTransfer.types.length !== 1 || e.dataTransfer.types[0] !== "Files") {
        return;
      }
      const { files } = e.dataTransfer;
      if (!allFilesAreImages(files))
        return;
      e.preventDefault();
      if (this.settings.showRemoteUploadConfirmation) {
        const modal = new RemoteUploadConfirmationDialog(this.app);
        modal.open();
        const userResp = yield modal.response();
        switch (userResp.shouldUpload) {
          case void 0:
            return;
          case true:
            if (userResp.alwaysUpload) {
              this.settings.showRemoteUploadConfirmation = false;
              this.saveSettings().then(() => {
              }).catch(() => {
              });
            }
            break;
          case false: {
            markdownView.currentMode.clipboardManager.handleDrop(DragEventCopy.create(e, files));
            return;
          }
          default:
            return;
        }
      }
      this.getEditor().replaceSelection("\n");
      const promises = [];
      const filesFailedToUpload = [];
      for (let i = 0; i < files.length; i += 1) {
        const image = files[i];
        const uploadPromise = this.uploadFileAndEmbedImgurImage(image).catch(() => {
          filesFailedToUpload.push(image);
        });
        promises.push(uploadPromise);
      }
      yield Promise.all(promises);
      if (filesFailedToUpload.length === 0) {
        return;
      }
      markdownView.currentMode.clipboardManager.handleDrop(DragEventCopy.create(e, filesFailedToUpload));
    });
  }
  get imgUploader() {
    return this.imgUploaderField;
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = __spreadValues(__spreadValues({}, DEFAULT_SETTINGS), yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  onload() {
    return __async(this, null, function* () {
      const sizes = ImgurSize.values();
      for (let i = 0; i < sizes.length; i += 1) {
        const size = sizes[i];
        this.addCommand({
          id: `imgur-resize-${size.suffix}-command`,
          name: `Resize to ${size.description}${size.sizeHint ? ` (${size.sizeHint})` : ""}`,
          editorCheckCallback: plugin_callback_default(size)
        });
      }
      yield this.loadSettings();
      this.addSettingTab(new ImgurPluginSettingsTab(this.app, this));
      this.setupImgurHandlers();
      this.setupImagesUploader();
    });
  }
  setupImagesUploader() {
    this.imgUploaderField = buildUploaderFrom(this.settings);
  }
  setupImgurHandlers() {
    this.registerEvent(this.app.workspace.on("editor-paste", this.customPasteEventCallback));
    this.registerEvent(this.app.workspace.on("editor-drop", this.customDropEventListener));
  }
  static showUnconfiguredPluginNotice() {
    const fiveSecondsMillis = 5e3;
    new import_obsidian6.Notice("\u26A0\uFE0F Please configure Imgur plugin or disable it", fiveSecondsMillis);
  }
  uploadFileAndEmbedImgurImage(file) {
    return __async(this, null, function* () {
      const pasteId = (Math.random() + 1).toString(36).substr(2, 5);
      this.insertTemporaryText(pasteId);
      let imgUrl;
      try {
        imgUrl = yield this.imgUploaderField.upload(file);
      } catch (e) {
        if (e instanceof ApiError) {
          this.handleFailedUpload(pasteId, `Upload failed, remote server returned an error: ${e.message}`);
        } else {
          console.error("Failed imgur request: ", e);
          this.handleFailedUpload(pasteId, "\u26A0\uFE0FImgur upload failed, check dev console");
        }
        throw e;
      }
      this.embedMarkDownImage(pasteId, imgUrl);
    });
  }
  insertTemporaryText(pasteId) {
    const progressText = ImgurPlugin.progressTextFor(pasteId);
    this.getEditor().replaceSelection(`${progressText}
`);
  }
  static progressTextFor(id) {
    return `![Uploading file...${id}]()`;
  }
  embedMarkDownImage(pasteId, imageUrl) {
    const progressText = ImgurPlugin.progressTextFor(pasteId);
    const markDownImage = `![](${imageUrl})`;
    ImgurPlugin.replaceFirstOccurrence(this.getEditor(), progressText, markDownImage);
  }
  handleFailedUpload(pasteId, message) {
    const progressText = ImgurPlugin.progressTextFor(pasteId);
    ImgurPlugin.replaceFirstOccurrence(this.getEditor(), progressText, `<!--${message}-->`);
  }
  getEditor() {
    const mdView = this.app.workspace.activeLeaf.view;
    return mdView.editor;
  }
  static replaceFirstOccurrence(editor, target, replacement) {
    const lines = editor.getValue().split("\n");
    for (let i = 0; i < lines.length; i += 1) {
      const ch = lines[i].indexOf(target);
      if (ch !== -1) {
        const from = { line: i, ch };
        const to = { line: i, ch: ch + target.length };
        editor.replaceRange(replacement, from, to);
        break;
      }
    }
  }
};
